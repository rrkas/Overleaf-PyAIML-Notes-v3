\section{Iterative Lengthening Search (ILS) \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}}
\label{AI: Algorithms/Iterative Lengthening Search (ILS)}


\begin{enumerate}
    \item an iterative analog to uniform-cost search, inheriting the Iterative deepening search algorithmâ€™s optimality guarantees while avoiding its memory requirements. The idea is to use increasing path-cost limits instead of increasing depth limits.
    \hfill \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}

    \item \textbf{Disadvantage}: It turns out that iterative lengthening incurs substantial overhead compared to uniform-cost search.
    \hfill \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}
\end{enumerate}


\vspace{0.5cm}


\begin{lstlisting}[
    language=Python,
    caption=Problem Solving Agent - Iterative Lengthening Search \cite{common/online/chatgpt}
]
def iterative_lengthening_search(problem: Problem):
    cost_limit = 0

    while True:
        result, new_cost_limit = uniform_cost_search_with_cost_limit(
            problem,
            cost_limit,
        )

        if result is not None:
            return result

        if new_cost_limit == float('inf'):
            return None

        cost_limit = new_cost_limit


def uniform_cost_search_with_cost_limit(problem: Problem, cost_limit: int):
    node = Node(problem.initial_state, None, None, 0)

    if problem.goal_test(node.state):
        return solution(node), cost_limit

    frontier = [(node.path_cost, node)]
    explored = set()
    heapq.heapify(frontier)
    next_cost_limit = float('inf')

    while frontier:
        path_cost, node = heapq.heappop(frontier)

        if path_cost > cost_limit:
            next_cost_limit = min(next_cost_limit, path_cost)
            continue

        if problem.goal_test(node.state):
            return solution(node), cost_limit

        explored.add(node)

        for action in problem.actions(node.state):
            child = child_node(problem, node, action)

            if (not any(child.state == n.state for n in explored) and
                not any(n.state == child.state for _, n in frontier)):
                heapq.heappush(frontier, (child.path_cost, child))

    return None, next_cost_limit
\end{lstlisting}






