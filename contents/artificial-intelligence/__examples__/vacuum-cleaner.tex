\section{Vacuum Cleaner (Toy problem) \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}}


\begin{figure}[H]
    \centering
    \includegraphics[
        width=0.5\linewidth,
        height=3cm,
        keepaspectratio
    ]{images/artificial-intelligence/examples/vacuum-cleaner-world.png}
    \caption{A vacuum-cleaner world with just two locations}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[
        width=\linewidth,
        % height=7cm,
        keepaspectratio
    ]{images/artificial-intelligence/examples/vacuum-state-space.png}
    \caption{The state space for the vacuum world. Links denote actions: L = Left, R = Right, S= Suck. \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}}
\end{figure}



\vspace{0.5cm}

\begin{enumerate}
    \item itâ€™s a made-up world

    \item This particular world has just two locations: squares A and B.

    \item The vacuum agent perceives which square it is in and whether there is dirt in the square.

    \item It can choose to \textbf{move left}, \textbf{move right}, \textbf{suck up the dirt}, or \textbf{do nothing}.

    \item One very simple agent function is the following: if the current square is dirty, then suck; otherwise, move to the other square.


\end{enumerate}



\subsection{As a table driven agent}

\begin{customArrayStretch}{1.3}
\begin{longtable}{|l|l|}

\hline
\textbf{Percept sequence} & \textbf{Action} \\ \hline
\endhead

\hline
\textbf{Percept sequence} & \textbf{Action} \\ \hline
\endfirsthead

\hline\endfoot
\hline\endlastfoot


$[A, \ Clean]$ & $Right$ \\
$[A, \ Dirty]$ & $Suck$ \\
$[B, \ Clean]$ & $Left$ \\
$[B, \ Dirty]$ & $Suck$ \\

\vdots & \vdots \\

$[A, \ Clean],\ [A, \ Clean]$ & $Right$ \\
$[A, \ Clean],\ [A, \ Dirty]$ & $Suck$ \\

\vdots & \vdots \\

$[A, \ Clean],\ [A, \ Clean],\ [A, \ Clean]$ & $Right$ \\
$[A, \ Clean],\ [A, \ Clean],\ [A, \ Dirty]$ & $Suck$ \\

\vdots & \vdots \\

\end{longtable}
\end{customArrayStretch}





\subsection{As a simple reflex agent}

\begin{algorithm}[H]
    \caption{The agent program for a simple reflex agent in the two-state vacuum environment.  \cite{ai/book/Artificial-Intelligence-A-Modern-Approach/Russell-Norvig}}

    \SetKwFunction{FUNCTION}{\textsc{Reflex-Vacuum-Agent}}
    \SetKwProg{Fn}{function}{ returns \normalfont{an action}}{end}
    \Fn{\FUNCTION{[location, status]}}{
        \textbf{if} $status \ = \ Dirty$ \textbf{then return} $Suck$ \\

        \textbf{else if} $location \ = \ A$ \textbf{then return} $Right$ \\

        \textbf{else if} $location \ = \ B$ \textbf{then return} $Left$ \\
    }
\end{algorithm}







\subsection{As a problem solving agent}

\begin{enumerate}
    \item \textbf{States}: The state is determined by both the agent location and the dirt locations. The agent is in one of two locations, each of which might or might not contain dirt. Thus, there are $2 \times 2^2\ =\ 8$ possible world states. A larger environment with $n$ locations has $n \cdot 2^n$ states.

    \item \textbf{Initial state}: Any state can be designated as the initial state.

    \item \textbf{Actions}: In this simple environment, each state has just three actions: Left, Right, and Suck. Larger environments might also include Up and Down.

    \item \textbf{Transition model}: The actions have their expected effects, except that moving Left in the leftmost square, moving Right in the rightmost square, and Sucking in a clean square have no effect.

    \item \textbf{Goal test}: This checks whether all the squares are clean.

    \item \textbf{Path cost}: Each step costs $1$, so the path cost is the number of steps in the path.
\end{enumerate}

\vspace{0.5cm}

{\centering \textbf{Defining Problem \& State} \par}

\begin{lstlisting}[language=Python]
vacuumActions = ["L", "R", "S"] # L: Left, R: Right, S: Suck
vacuumSquareState = ["D", "C"] # D: Dirty, C: Clean

class VacuumState(State):
    def __init__(self, squareA, squareB, currLoc):
        self.squares = {}
        self.squares["A"] = squareA
        self.squares["B"] = squareB
        self.currLoc = currLoc

    def __str__(self):
        return (
            "<VacuumState " +
            f"squares={self.squares} "+
            f"currLoc={self.currLoc}>"
        )

    def __repr__(self) -> str:
        return str(self)

    def __eq__(self, __o: object) -> bool:
        return str(self) == str(__o)

    def copy(self):
        return VacuumState(
            self.squares["A"],
            self.squares["B"],
            self.currLoc,
        )

class VacuumProblem(Problem):
    def __init__(self, initial_state: VacuumState):
        self.initial_state = initial_state

    def step_cost(self, state: VacuumState, action: str, new_state: VacuumState):
        return (int(state.squares[state.currLoc] == "D" and action == "S")
            + int(state.currLoc == "A" and action == "R")
            + int(state.currLoc == "B" and action == "L"))

    def result(self, state: VacuumState, action: str):
        state = state.copy()

        state.currLoc = {
            "L": "A",
            "R": "B",
        }.get(action, state.currLoc)
        state.squares[state.currLoc] = {
            "S": "C"
        }.get(action, state.squares[state.currLoc])
        return state

    def actions(self, state: VacuumState):
        actions = []

        if state.squares[state.currLoc] == "D":
            actions.append("S")

        if state.currLoc == "A":
            actions.append("R")

        if state.currLoc == "B":
            actions.append("L")

        return actions

    def goal_test(self, state: VacuumState):
        return all([v == "C" for v in state.squares.values()])

init_state = VacuumState("D", "D", "A")
\end{lstlisting}



{\centering \textbf{Solution using breadth\_first\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = breadth_first_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}



{\centering \textbf{Solution using uniform\_cost\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = uniform_cost_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}



{\centering \textbf{Solution using depth\_first\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = depth_first_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}



{\centering \textbf{Solution using backtracking\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = backtracking_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}



{\centering \textbf{Solution using depth\_limited\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = depth_limited_search(problem, 5)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node

print("\n\n")

problem = VacuumProblem(init_state)
path = depth_limited_search(problem, 2)
print(path)

if isinstance(path, list):
    node = Node(init_state, None, None, 0)
    print(node)
    for a in path:
        new_node = child_node(problem, node, a)
        print(a, new_node.state, new_node.path_cost, new_node)
        node = new_node
\end{lstlisting}



{\centering \textbf{Solution using iterative\_deepening\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = iterative_deepening_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}



{\centering \textbf{Solution using iterative\_lengthening\_search} \par}

\begin{lstlisting}[language=Python]
problem = VacuumProblem(init_state)
path = iterative_lengthening_search(problem)
print(path)

node = Node(init_state, None, None, 0)
print(node)
for a in path:
    new_node = child_node(problem, node, a)
    print(a, new_node.state, new_node.path_cost, new_node)
    node = new_node
\end{lstlisting}


